# DSKR.DEV: как я пришёл к preact и SSR

Активность matinintim.com в декабре заставила меня задуматься о написании собственного блога. Идея витала давно, но тут появился отличный повод. Домен и серве уже был, и я решил начать писать. 
В изначальном плане я думал использовать node.js и какойни-будь шаблонизатор, но посмотрев на десяток попылярных шаблонизаторы, я заплакал и понял что бу jsx жить больше не могу. вариантов с jsx я нашел всего. Один из них был тупо генератор из jsx в html, но он не дружил с typescipt, что было критично для меня. а второй был тупо react на бекенде. Тогда то я и понял что в любом случае придется брать преакт, ибо реакт слишком жирный, и пилить SSR ибо индивеб без SSR не работает.
к счастью, прикуртить SSR к преакту оказалось совсем не сложно.
В первой итерации было решено использовать parcel для сборки фронтенда ибо это самы простой вариант.
Ноду запскал используя ts-node-dev. На ноде решил писать на koa, ибо express немного надое. Я конечно привык что в express'е нет body-parser, но то что в koa не будет роутера я совсем не ожила. но это мелочи. Нода так же раздёт статику, и в проде и в деве, вышло както так. фаил назвал `server.ts`
```typescript

import Koa from 'koa';
import Router from '@koa/router';
import Static from 'koa-static';

import { renderApp } from './ssr';
const app = new Koa();

const router = new Router();


router.get(['/', '/p/*'], (ctx)=> ctx.body=renderApp(ctx.url));

app.use(Static('./dist'));
app.use(router.routes());

app.listen(4000);
```
всё что тут происходит это поднятие koa сервера, раздача статики и конечно же вызов функции рендерющей фронтенд часть приложения.

Само приложение расположилось в файле app.tsx 
```jsx
import { h } from 'preact';
import { setPragma } from 'goober';
import { Router, Link } from 'preact-router';

import { Grid } from './grid/component';

import { MainPage } from './page/main/component';
import { PostPage } from './page/post/component';

setPragma(h);

interface IProps {
  url?: string;
}

export const App = ({url}: IProps)=>{


  return (
    <Grid>
      <Router url={url}>
        <MainPage path="/"/>
        <PostPage path="/p/:year/:month/:day"/>
      </Router>
    </Grid>
  )
};
```
и в целом тут ничего интересного, обычной preact, обычный роутер, которому можно передать текущий url через пропсы и новенькая библиотека для jsx `goober`, у неё очень маленький рантайм, минималистичный api и она умеет в SSR.

Ну а дальше фаил ssr.tsx который выполняет всю магию серверсайд рендеринга:
```jsx
import { h } from 'preact';
import render from 'preact-render-to-string';
import { extractCss } from 'goober';

import { App } from './app';

const cache = new Map<string, string>();

const realRender = (url: string) => {
  const app = render(<App url={url} />);
  const style = extractCss();

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>DSKR.DEV</title>
  <link rel="microsub" href="https://aperture.p3k.io/microsub/448">
  <link rel="authorization_endpoint" href="https://indieauth.com/auth">
  <link rel="token_endpoint" href="https://tokens.indieauth.com/token">
  <style>${style}</style>
</head>
<body>
  <div id="app">${app}</div>
  <script src="/web.js"></script>
</body>
</html>
`;
};

export const renderApp = (url: string) => {
  if(cache.has(url)) {
    return cache.get(url);
  }
  const app = realRender(url);
  process.nextTick(() =>cache.set(url, app));
  return app;
};
```
функцция `realRender` собственно и выполняет сам рендеринг, там ничего сложного, используем `preact-render-to-string` для ренеринга яhtml, `extractCss` для получения стилей из `goober` а дальше вставляем всё в html.

ну а функция `renderApp` тупо кеширует результат функции `realRender`. ибо рендер preact приложения, даже такого маленького, не такая уж и сложная задача и занимает 200-300мс. а так мы выполняем рендер один раз, а дальше отдаёт готовый html, учитывая что это почти статический блог, это идеяльное решение.

Ну а точка входа в веб приложение выглядит вот так, web.tsx
```tsx 

import { h, render } from "preact";
import { App } from "./app";

render(<App />, document.body, document.getElementById("app") || undefined);
```

тут просто тело страницы и наше приложение отдаём функции render, дальше вся магия произойдёт без нашего участия.

В результате я получил простейщее приложение на preact с SSR, JSS и typescript. Ну а в следующих частях я раскажу как я добавил стейт, научился парсить markdown, подсвечивать синтаксис в блоках кодах, и поднял свой micropub server(На это особенно надеюсь).